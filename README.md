# Язык программирования Aqua
<p align="center">
  <img src="aqua_logo.svg" alt="Aqua logo" width="120" height="120">
</p>

## О языке
- **Аква и точка.**
- Язык общего назначения
- Компилируемый
- Строго типизированный
- Благодаря своей простоте, язык должен быть привлекателен для начинающих программистов, но также предоставлять продвинутые возможности для опытных разработчиков.
- Большая часть работы ложится на компилятор. Он автоматически определяет большинство типов переменных и возвращаемых значений. Также на компилятор ложится ответственность за безопасность по памяти.
- Реализует ООП: одиночное наследование, полиморфизм и нестрогая инкапсуляция
- Имеет интроспекцию (можно узнать класс, к которому принадлежит объект) и рефлексию.
- Любое значение является объектом, а любая операция — вызовом метода
- Есть сходства с Java, Python, JS, Kotlin, Rust, Dart, C++.

Хотелось бы видеть:
- Поддержка работы с указателями и памятью, как возможный конкурент C++
- Совместимость с кодом, написанным на C или C++ используя ABI и FFI. То есть в коде aqua вызывается `import vector.h`, а потом `vector` используется, как обычный класс. Схожим образом можно импортировать библиотеку `.dll`.
- Встроенная поддержка многопоточности и параллельного программирования
- Возможность написания низкоуровневого кода
- Встроенная библиотека для работы с файлами и сетью
- Широкий спектр доступных библиотек и модулей
- Возможность написания быстрого и эффективного кода
- Компиляция в js, web-assembly или другое
- Удобный и простой в использовании пакетный менеджер, как pip в python
- Компиляция в библиотеку (как dll в С++)
- Ведение AEP Aqua Enhancement Proposals
- Генерация документации, как в JavaDoc
- Разделы документация для программистов на Java, документация для программистов на C++ для более быстрого ими освоения
- Горячее изменение кода
- Стандартная графическая библиотека
- Встроенная система тестов
- Компиляция для микроконтроллеров. То есть сборка .elf и .hex файлов под разные архитектуры 
- Поддержка системных вызовов
- Встроенная система сборки под названием `bottle`. 


### Идеология (фразочки)
- Почему **Aqua**? Потому что код чистый, как стёклышко!
- Что можно сказать о логотипе? Aqua и точка!
- Безопаснее чем C++, короче, чем Java, читаемее, чем Python, легче, чем Rust, но быстрый, как C.
- Как можно меньше лишнего
- Если сильно нужно, то можно
- 3-5 букв - самое то
- Для своей цели должен быть один инструмент, а не набор из устаревших, рекомендуемых и экспериментальных
- Лучше умный компилятор, чем усталый программист
- Программист не должен держать много в голове

### Актуальность
- Существующие языки программирования вполне покрывают потребности большинства сфер, однако существуют области, где они не способны решить проблемы в эффективном и удобном для разработчика виде.
- Создание нового языка программирования позволяет улучшить производительность, упростить разработку, улучшить читаемость кода и сделать его более надежным. 
- Необходимо также учитывать сложность создания нового языка, требования к обучению разработчиков новому языку и возможность его внедрения в существующий стек технологий.
- Сравнение существующих концепций управления памятью:
- - **C++**: В C++ управление памятью может быть ручным или автоматическим. Ручное управление памятью предполагает, что программист самостоятельно выделяет и освобождает память для объектов. Автоматическое управление памятью реализовано с помощью механизма RAII (Resource Acquisition Is Initialization) и сборки мусора. RAII предполагает, что ресурсы, включая память, должны быть выделены при создании объекта и освобождены при его уничтожении.
- - **Java**: В Java управление памятью осуществляется автоматически с помощью механизма сборки мусора. Сборка мусора осуществляется периодически, когда система определяет, что объект больше не используется.
- - **Rust**: В Rust управление памятью осуществляется с помощью механизма аренды (borrowing) и системы владения (ownership). Аренда позволяет временно заимствовать память, не переводя ее в собственность. Система владения гарантирует, что каждый объект имеет единственного владельца, что устраняет проблемы с конфликтующими доступами к памяти.

Каждый подход имеет свои преимущества и недостатки, и выбор зависит от требований приложения и специфики языка программирования. Автоматическое управление памятью упрощает жизнь программисту, но может иметь проблемы с производительностью. Ручное управление эффективно, но может привести к утечкам памяти и сбоям приложения. Механизм владения в Rust решает проблемы с утечками памяти и конфликтующим доступом к памяти, но требует от разработчика больше внимания и знаний, а также накладывает некоторые ограничения.
### Целевые применения
- Написание серверов
- Математические вычисления
- Написание ПК и консольных приложений
- Инструменты для обработки больших объемов данных, что пригодится для анализа данных и машинного обучения
### Принцип работы с памятью
- По умолчанию всё везде передаётся по ссылкам, кроме int, float, long, char и других, т.к. к ним применён модификатор `autocopy`.
- В языке всё должно быть инициализировано, никаких null.
- Используется концепция, схожая на владение в Rust
- Существует 4 вида сущностей: **object, read-only reference, mutable reference, free-object**. **free-object** - скопированный объект, анонимный объект или литерал.
```dart
Комментарии подписывают, чем является левая часть выражения.
a_obj = Animal()    //object
ro_ref = a_obj      //create read-only reference
mut_ref = &a_obj    //create mutable reference
ro_ref2 = ro_ref    //create read-only reference
ro_ref3 = mut_ref   //create read-only reference
mut_ref2 = &ro_ref  //create mutable reference
mut_ref3 = &mut_ref //create mutable reference
c_obj = $a_obj   //copied object
c_obj2 = $ro_ref //copied object
ro_ref = ro_ref2 //rewrite read-only reference
ro_ref = mut_ref //rewrite read-only reference
mut_ref = ro_ref //error
a_obj = ro_ref   //error
a_obj = mut_ref  //error
a_obj = $ro_ref  //rewrite a_obj
a_obj = $mut_ref //rewrite a_obj
mut_ref = mut_ref2  //rewrite mutable reference
mut_ref = &mut_ref2 //rewrite mutable reference

a_obj2 = Animal() //object
a_obj2 = a_obj    //copy a_obj to a_obj2
a_obj2 = ro_ref   //error
a_obj2 = mut_ref  //error
a_obj2 = &a_obj   //error
ro_ref4 = a_obj2  //create read-only reference
ro_ref4 = $ro_ref //copy a_obj to a_obj2

//Functions, that takes:
foo1(Animal a)  //read-only reference
foo2(Animal &a) //mutable reference
foo3(Animal $a) //free object

foo2(ro_ref)  //error
foo3(ro_ref)  //error
foo3(mut_ref) //error
foo1(mut_ref) //correct
foo3($ro_ref) //correct
foo1(a_obj)   //correct
foo2(a_obj)   //correct
foo3($a_obj)  //correct
foo3(a_obj)   //copy of a_obj
foo3(ro_ref)  //error
foo3(mut_ref) //error

bar1(Animal a, Animal a2)   //2 read-only references
bar2(Animal &a, Animal &a2) //2 mutable references

bar1(ro_ref, ro_ref) //correct
bar1(mut_ref, a)     //correct
bar1(a, a)           //correct
bar2(mut_ref, a)     //error, 2 mutable references
bar2(a, a)           //error, 2 mutable references
bar2(a, a_obj2)      //correct
bar2(a, $a)          //correct
```
- Одновременно может быть только одна **mutable reference** или много **read-only reference**. Одновременно и того, и другого быть не может, чтобы не получилась ситуация, что из одного потока объект изменяют, а из другого читают. При выходе из области видимости они удаляются.
- Через **read-only reference** нельзя вызывать у объекта изменяющие функции. К этим функциям относятся те, что вызывают оператор `=` у какого-то из полей класса. Это свойство учитывается только на этапе компиляции.
- **mutable reference** ведёт себя, как и **object**, позволяет изменять объект
- Можно просто в коде писать фигурные скобки `{ ... }`, чтобы создать область видимости, при выходе из которой, объекты удалятся.
## Синтаксис
### Синтаксические нормы
- Использование ; только при написании в одной строке (как в js)
- Комментарии с помощью `//` и `/* */`
- Табуляция не важна
- Названия классов с большой буквы PascalCase
- Названия функций через camelCase
- Названия переменных через snake_case
- Константы БОЛЬШИМИ буквами
### Общее
- В циклах и условиях наличие круглых скобок необязательно. Пример: `if a>5 { ... }`
- Инициализация переменной: `a = Animal(24)`, объявление переменной - `Animal a`. Объявленные переменные должны быть обязательно инициализированы, иначе будет ошибка компиляции.
- Всё построено на классах. Даже int является alias от Integer. Поэтому будет работать код `int.class.name`. Хотя неявно компилятор старается использовать примитивный int, где возможно.
- Цикл for - `for (var_name : Number) { ... }`. Можно менять начальное и конечное значение: `for (i = 3 : arr.len-1) { ... }` равносильно `for(i = 3; i<arr.len-1; i++){ ... }`. Если индекс `i` не нужен, можно написать `for(5){ ... }`, но к `i` по прежнему можно обратиться через `it`. Для итерации в обратном порядке или с другим шагом нужно написать число (работает только с числами): `for (i:24:2)` - с шагом 2, `for (i=5:0:-1)` - с обратным шагом. Равносильно `for (i=5; i>=0; i--)`. Предусмотрена безопасность для `unsigned` типов. Для более сложной логики необходимо использовать while.
- Цикл foreach может применяться к объектам, которые реализовали интерфейс `Iterable`. Пример: `for (x : arr)`, где для `x` автоматически определится тип данных, исходя из массива `arr`. `for (x : arr : -1)` - для обратного порядка. `for (i, value: arr)` - как enumerate в python. `for (key, value : dict.pairs())` - с распаковкой, `for (i, key, value : dict.pairs())` - индекс и распаковка, `for (i = it+4: arr){ ... }` равносильно `for (x:arr){ i = x+4; ... }`.
- Возможность возвращать из функции несколько значений через запятую: `return .4 , 5, "hi"`. Они преобразуются в кортеж `Tuple<double,int,str>`. Для передачи элементов как массив, следует использовать `return [.4, 5, "hi"]`, они преобразуются в `Array<Any>`.
- Swap переменных `a,b,c = c,b,a`, как в python. Для двух переменных предпочтительнее использовать `a >< b`
- Групповое, множественное присваивание: `a,b,c = 1,3,2`, `a,b,c = 0`, но `a,b,c = 1,2` - compilation error
- Висячие запятые: при создании массивов или в аргументах функции можно оставлять последней запятую. Пример: `arr = [1,2,]`, `println(1,2,)`
- Тернарный оператор как в kotlin: `max_num = if (a > b) a else b`
- Scope functions, как в kotlin
- Мультисравнения, как в python: `4 < a <= 6`
- `i++` и `++i` не возвращают значения, чтобы повысить читаемость кода
### Операторы
- Переопределение операторов синтаксисом: `_+=(int num){ ... }`, `_==(int num) => this.len == num`
- Вызов оператора, как функцию класса: `str._+("hi",5)` равносильно `"hi"+5`
- `**` - возведение в степень
- `==` - сравнение по значению (вызов реализованной в классе функции сравнения). По умолчанию рекурсивно вызывает `==` у полей класса.
- `&==`, `&!=` - сравнение по ссылке. Не может быть переопределён.
- `.=` - вызов функции с присваиванием. Пример: `obj.=fun()` равносильно `obj=obj.fun()`
- `...` - произвольное количество аргументов (как в java). По сути, это массив. После аргумента `...` могут идти и другие аргументы, но они должны иметь значение по умолчанию. 
- `:Class` - преобразование типа (cast). Пример: `value:str` будет аналогичным `(String)value` в java. Если оператор не переопределён для класса, вызовет конструктор: `some_number:str` вызовет `str(some_number)`, т.к. у объекта `some_number` нет соответствующего метода.
- `#` - распаковывает iterable объекты (как `*` в python). Если в iterable объекте больше элементов, чем нужно, то оставшиеся он проигнорирует. Если меньше - вызовет exception в debug режиме. Пример: `println(#arr)`, `int a, str b = #foo()`, `a,b,c = #(1,4,0) arr` - индексы элементов, которые нужно взять, `#(2:5)` - равносильно `#(2,3,4)`, `#(:-1)` - до предпоследнего элемента, `#(1:)` - с индекса 1 до конца iterable. `a,b = #(0,2)[1,2,3]` или `a,_,b = #[1,2,3]` - пропуск элемента. Распаковка как в julia: `front..., tail = "Hi!"`, где получится, что `front` - это строка `Hi`, а `tail` - строка `!`.
- `.` - по умолчанию - это обращение к полям и методам объекта. Если такого поля в классе нет, то вызывается оператор `_.(str s){ ... }`, где можно реализовать свою логику
- `$` - оператор копирования (deep copy). Нельзя переопределить. Копирует не указатели, а все элементы. Может продлить жизнь объекту. Напоминает, что это дорогая операция. Пример `return &obj` (obj не будет уничтожен при выходе из области видимости и копирования не произойдёт). Ещё пример: `$&obj` - сначала вернёт ссылку, а потом увеличит время жизни ссылки. 
- `=` - оператор присваивания может быть переопределён только для других типов, т.е. `_=()` может принимать все типы, кроме своего и своих потомков, так как это означает перезапись ссылки на объект. Пример: есть класс `Animal` и `Cat`, где второй является наследником первого. Код `animal = cat` перезапишет ссылку, а `cat = animal` вызовет оператор `_=(Animal a)` для объекта `cat`.
- `[:]` - оператор срезов. `:` может быть и несколько: `arr[1:5:-1]`. При пропуске значения `arr[:3]` вызовется оператор `_[](,3)`. Для этого в классе должно быть определено значение по умолчанию: `_[](int start = 0, int end = this.len){ ... }`
- `[]` - может принимать параметры через запятую. Для `arr[2,5]` вызовется `_[](int i1, int i2)` или, если есть, `_[](int... indices)`. У первого варианта приоритет больше.
- `&`, `|`, `!`, `!=` - логические операторы. Для операторов `&`, `|` с чиселами будет применяться побитовое умножение, для булевых - логическое, а для других классов вызываться метод `_&`.
- `<<`, `>>`, `~`, `^`, `&`, `|`  - битовые операторы.
- `&var` - оператор создания изменяемой ссылки (mutable reference). `ref = &obj` визуально взаимодействие с ссылкой выглядит так же, как и с оригинальным объектом???
- `><` - оператор обмена переменных (swap). Нельзя переопределить. Вызывается рекурсивно для всех полей класса. Может быть использовано вместо move для обмена объектов данными (указателями). Для указателей не копирует данные, а меняет указатели. Не может быть применён для **read-only reference**. Пример: `a >< arr[0]`
- `()` - для реализации дополнительного функционала
- `@` - для реализации дополнительного функционала. Например, матричное перемножение
- `$=` - ?
- `?` - ?
- `*variable` - ?
- `::` - ?
### Функции
- Синтаксис: название, аргументы, тело функции. Если функция состоит из одной строчки, вместо фигурных скобок можно написать `=>`. Если будет что возвращать, оно вызовет `return`. Перед функцией возвращаемый тип не указывается, он определяется автоматически. Если нужен другой тип, то делаем cast к этому типу. Пример:
```dart
sum(int a, int b) => a+b
mul(float a, float b){
    return (a*b):int
}
```
- Если функция не принимает аргументов, в определении можно не писать фигурные скобки: `fun(){ ... }` равносильно `fun{ ... }`
- Поддержка как перегрузки функций, так и значений по умолчанию. Причём в значения по умолчанию можно записывать выражения или вызывать функции. Также, аргумент можно пропускать через `,,`, если указано его начальное значение. Пример:
```dart
foo(int<> l, int len = l.size(), int sqrt = Math.sqrt(len)){ ... }
foo(<1,2,3>,,4)
foo(<1,2,3>,sqrt=4)
```
- Передача параметров не по порядку, как в python: `println("Hello, there",24, end="!!!")`
- Callback функция, которая передаётся как параметр, будет без проблем вызываться, даже если она принимает меньше параметров (как в js). Пример: в функцию `foo(Function<Event, int, int => void> fun) ` можно передать как `bar(Event e, int a, int b)`, так и `baz(Event e)`
- Анонимные функции: `foo = (int a, int b = 3)=>{ return a+b }` или `bar = (List l) => l.size()`. Такие же как стрелочные функции в js. Если передаём функцию как параметр, значит известна её сигнатура и можно записать в краткой форме: `foo( e=>e.getX() )` и `foo( =>it.getX() )` или `foo( (a,b) => { int c = a+b; return c } )` и `foo(=> it+it[1])`
- Допустим, есть перегруженная функция `foo(str s)` и `foo(Any any)`. При вызове `foo("hi")` и `foo(5)` вызовется первая и вторая соответственно.
## Встроенная библиотека
### Стандартные функции
- print(arguments..., split=' ') - печатает `arguments` в консоль с разделителем `split`. Вызывает `:str` у аргументов
- println(arguments..., split=' ', end='\n') - как print, только в конце печатает `end`
- help(obj, short=true) - печатает документацию, в том числе путь до исходника. Если short=false, выведет только названия и типы без документации. 
- type(obj) - возвращает строку: имя класса объекта `obj.class.name` и, если есть, дженерики в `<>` скобках `obj.class.generics`. Пример: `println(type(dict))` **->** `"Dict<int, str>"`.
- inputLine(msg, end_line="\n") - работает как `input()` в python
- input(msg, split=" ", end_line="\n") - если буфер пуст, то считывает строку, но возвращает только слово до разделителя `split`. Остальное записывает в буфер
- inputClear() - очищает буфер, который мог заполниться функцией `input()` 
- sizeOf(obj) - размер объекта в байтах
- assert(condition, msg) - функция которая работает только в debug режиме. Если `condition == false` - печатается `msg` и кидается exception
### Классы
- `Any` - класс, от которого неявно все наследуются (как Object в java). Имеет стандартно реализованные функции:
  - `:str=>type(this)` - перевод в строку по умолчанию
  - `const Class class` - переменная, содержащая ссылку на экземпляр своего класса. При приведении типа сравнивается реальный тип и тот, к которому мы приводим.
  - `hash` - ?
  - `==` - сравнение по умолчанию (вызов `==` для каждого из полей)
- `Collection` - абстрактный класс. Обязывает реализовать оператор `[]` и имеет длину `len`
  - map(function/class) - как в python. `class` должен иметь конструктор, который принимает такой же тип, как элементы в iterable.
  - filter(function) - возвращает объект того же типа как в python
  - sort(comparator) - возвращает массив, как в python
  - max(comparator)
  - min(comparator)
  - mean()
  - sum()
  - count(function)
  - any(function) - по умолчанию function - `=>it:bool`
  - all(function)
  - none(function) - как в kotlin
  - forEach(function) - как в js
  - reduce(function, start_value=this[0]) - как reduce в functools в python
  - contains(value) - return true если значение есть в iterable.
  - where(function) - Возвращает первый элемент, удовлетворяющий условию, иначе - возвращает последний элемент iterable. function возвращает тип bool. 
  - prod() - произведение всех элементов (product)
- `Iterable` - интерфейс. Обязывает реализовать метод, который возвращает `Iterator`. Цикл for each неявно вызывает этот метод.
- `Array` - стандартный неизменяемый массив. Реализует iterable. Конструктор может принимать iterable.
  - Стандартный синтаксис `arr = Array<int>(3)`
  - Короткий синтаксис `arr = int[3]`
  - `int[] arr` - объявление без инициализации
  - Инициализация `arr = int[]` равносильна `arr = Array<int>()`, то есть длина будет 0.
  - Объявление `int[][] arr` равносильно `Array<<int>> arr`. Это настоящий двумерный массив, в отличие от DimArray.
  - Может создаваться синтаксисом `arr = [1,2,4]`, `arr = [5]` - массив длиной 1
  - Конструктор из строки: `arr = Array.parse<int>("[1.2,2 , 4]")` - приведёт всё к int
  - Имеет длину `const int len`
  - Имеет красивый вывод в консоль `[1,2,4]`
  - Встроенные функции, такие как indexOf, binarySearch и т.д.
  - Поддержка отрицательных индексов
  - Срезы синтаксисом `[from:to]`. Необязательно указывать оба параметра. То есть `s[,5]` равносильно `s[0,5]`. Поддерживает отрицательные индексы.
  - Синтаксис `[] arr` недопустим. Следует писать `Array arr`
  - Для инициализации массива объектами используется конструктор без параметров. Для эффективности создаёт один такой объект, а далее копирует до конца массива.
  - При вызове конструктора по умолчанию `arr = Array<int>()` создаётся массив длинны 0. Его можно переприсвоить `arr = $arr2`, const len изменится.
  - Конструктор `Array.raw()` не инициализирует значения, а оставляет те, которые были в оперативке.
- `List` - расширяемый массив (как ArrayList в java)
  - Стандартный синтаксис `list = List<int>(5)`
  - Короткий синтаксис `list = int<5>` или `list = int<>`
  - `int<> list` - объявление без инициализации
  - Может создаваться синтаксисом `List([1,2,4])`
  - В консоль выводится в виде `<1,2,3>`
  - Синтаксис `list = <>` или `<> list` недопустим. Следует писать `List list`
- `DimArray` - (dimensional array) ведёт себя как многомерный массив, но внутри является одномерным. Неизменяемый.
  - Имеет поле `shape` (размеры измерений). Функция `reshape()` изменяет размерность
  - Оператор `[]` возвращает `DimArray`, поэтому, чтобы получить значение, нужно использовать функцию `value()`
  - Имеет горизонтальные и вертикальные срезы, поддержкой шага, как в numpy
  - Статистические функции, такие как `mean`, `median`, `mode`
  - `groupBy(column, axis)` - группирует данные (как в pandas). Возвращает объект `DimArray`
  - Работа с матрицами: `determinant()`, `transpose()`
- `Table` - класс, аналогичный pandas в python. Каждый столбец имеет свой тип.
- `LinkedList` - массив с быстрым удалением за счёт переписывания ссылок.
- `Dict` - словарь
  - Стандартный синтаксис `dict = Dict<int,float>()`
  - Короткий синтаксис `dict = {int : float}`
  - `{int : float} dict` - объявление без инициализации
  - Может создаваться синтаксисом `{1:24, 2:12}`
  - Обращение может происходить как через `[]` - `dict["hi"]`, так и через `.` - `dict.hi`, т.к. переопределён оператор `.`
  - Имеет поля `keys` и `values`
  - Есть функция `pairs()`, как в python
- `Set` - словарь
  - Стандартный синтаксис `set = Set<int>()`
  - Короткий синтаксис `set = int{}`
  - Инициализация синтаксисом `set = {1,2,3}`
- `Tuple` - кортеж. Используется для хранения разных типов в одной структуре
  - Стандартный синтаксис `tuple = Tuple<int, str, float>()`
  - Короткий синтаксис `tuple = (1, "hello", 4.1)`
  - Есть оператор сравнения, длина len, не относится к Iterable.
  - Обращение к элементам через `[]`. Индекс должен быть константным. Пример: `num = tuple[0]`. Тип указывать не нужно, т.к. он известен у tuple.
  - Можно менять элементы: `tuple[0] = 24`
  - Именование кортежа: `tuple = (one,t,th)(1,2,3)` или `tuple = (one,t,th) Tuple<int, str, float>()`, чтобы потом обращаться как `tuple.one`
  - Часто используется с оператором `#`. `a,b,c = #tuple` - распакует кортеж и создаст переменные с нужными типами.
  - Операторы `++`, `/`, `*` и другие, которые бы применялись поэлементно. Компилятор бы проверял, реализованы ли такие операции в классе.
- `Tree` - дерево на ссылках
- `ArrayTree` - дерево на массиве
- `Counter` - наследуется от `Dict<T,uint>`
  - `count(obj)` - функция создаст во внутреннем словаре пару `obj:1`, а если `obj` уже есть, то увеличит счётчик
  - В конструктор можно передать объект iterable, где для каждого элемента вызовется функция `count(obj)`
  - `Counter(Iterable iter, Function<int=>T> fun= (=>iter.iterate(it)) )` - функция которая определяет, по какому элементу считать.
- `Json` - тот самый json (наследуется от `Dict<str,Json>`)
  - Имеет конструктор, принимающий str
  - `pretty()` - возвращает json строку в приятном виде
  - Внутри имеет поля типов `str` - значение в виде строки, `Array<Json>` - значение  массив. При обращении через `[]` обращается во внутренний словарь и возвращает `Json` объект.
  - Получение данных из Json: , `json.pages[1].views:int`, либо благодаря `autocast` написать `int views = json.pages[1].views`
  - `str()` - функция возвращает значение узла: `json.pages[1].title.str()`. Нельзя использовать `:str`, т.к. оно используется при печати в консоль. Сеттер не нужен, т.к. переопределён оператор `=`.
  - `array()` - возвращает `Array<Json>.map(=>it.str())`.
  - `jsonArray()` - функция возвращает массив `Array<Json>`.
  - `isNull()` - возвращает `str == "null"`
  - `isEmpty()` - возвращает `this.isEmpty() && str.isEmpty() && array.isEmpty()`
  - Запись в Json: `json.page.number = 5` - если ключа `number` в словаре нет, выкинет исключение. Нужно добавить значение в json: `json.page.add("number",5)` или `json.page+="number"`. `json.pages = [1,"hello"]` - автоматически конвертирует массив в `Array<Json>`. 
  - Немного о реализации: оператор cast вызывается только для внутренней str, оператор `_[](int i)` возвращает элемент из внутреннего массива, а оператор `.` или `_[](str s)` возвращают Json
  - Применён `autocast` для int, long, double, float, но не для str. Примеры: `int views = json.pages[1].views`, `int rate = json.pages[1].rate:float`
  - Если в входной строке json будет значение `{key:[]}`, то массив будет иметь длину 0, а если `{key:{}}`, то объект будет иметь пустой массив и пустую строку.
  - Класс имеет ленивую подгрузку - то есть строка будет парситься, только тогда, когда она будет вызвана.
- `HashDict`
- `HashList`
- `INumber` - интерфейс, от которого наследуются все численные типы.
  - Все числа имеют константы MAX и MIN.
  - Функции по типу `isSafeAdd(n1,n2)` которая возвращает false, если при сложении переменная переполнится.
- `IFloat` - интерфейс, от которого наследуются float и double.
- `IIntger`- интерфейс, от которого наследуются все целочисленные типы: short, int, long
- `SystemInt` - имеет размер разрядности системы: 4 или 8 байт. Alias - `sint`. Беззнаковое число (Unsigned)
- `BigLong` - Long занимает 64 бита, а BigLong 128. Есть alias `blong`
- `ByteNumber` - класс с реализацией длинной арифметики
  - В конструктор принимает int - количество байт, которое занимает число
- `LongNumber` - класс с реализацией длинной арифметики
  - В отличие от предыдущего, может хранить число неограниченного размера
- `Class` - все классы неявно будут экземплярами этого класса
  - `name` - имя класса
  - `package` - имя пакета
  - `children` - массив классов-наследников
  - `size` - минимальный размер объекта в байтах (размер указателя 4 или 8 байт)
  - `generics` - массив с типами дженериков. Он может быть и пустой.
  - Через точку можно обратиться к static переменным, либо к функциям класса. Для их вызова функций первым параметром обязательно нужно будет передать объект этого же класса (передать this).
  - Оператор `class.new()` вызовет конструктор.
  - `Class.properties(obj)` - вернет словарь `Dict<str,Any>`, где ключ - имя поля класса, а значение - ссылка на него. 
- `Function` - все функции неявно будут экземплярами этого класса. Сигнатура описывается как: `аргументы => возвращаемое_значение`. Если функция ничего не возвращает, ничего не пишется. Пример: `Function<int, Any => >`, `Function< => >` - функция, которая ничего не принимает и ничего не возвращает.
  - `name` - имя функции
  - `type` - тип возвращаемого значения
  - `arguments` - массив из типов принимаемых аргументов
  - Оператор `()` исполняет эту функцию
  - Сигнатура описывается как `Function<float, float => int> f` - принимает два float, возвращает int, `Function< =>void> f`- ничего не принимает, возвращает что угодно или ничего не возвращает.
- `String` - является массивом из `char`. Является Iterable
  - Стандартный синтаксис `string = String()`
  - Короткий синтаксис `string = ""` или `string = ''`
  - Строки можно записывать в `'` и `"`. Чтобы создать символ, нужно использовать явный тип `char c = "!"` или использовать одинарные кавычки `c = '!'`
  - Встраивание переменных в строку через `$`. Пример: `println("Hello, $i")` или можно заключать выражения в скобки `$( )`,`${ }`: `println("Hello, $(i+1)")`. `"${=a}"` преобразуется в `"a="+a`.
  - Может быть изменена отдельная буква: `s[2] = 'h'`
  - Поддержка отрицательных индексов
  - Функции trim, chop
  - Функция `replace(old_str, new_str, limit=-1)` по умолчанию будет заменять все строки, но если указать `limit=2`, то заменятся только первые две.
  - Функция `replaceF()` - first ???
- `Text` - тот же, `String`, только изменяемый
- `Regex` - регулярные выражения. Поддерживает разные движки регулярок.
  - Конструктор, который принимает строку `Regex("a[bcd]+")`
  - Имеет короткий синтаксис `/my regex/` (как в js)
- `Pointer` - указатель. Является интерфейсом с native методом, поэтому напрямую не может быть создан его экземпляр.
  - Стандартный синтаксис `Pointer<int> ptr`
  - Краткий синтаксис `int* ptr`
  - Оператор `_[](int i)` вызывает код, равносильный `*(ptr+i*sizeof(Type))` и возвращает ссылку `&` на объект.
  - Внутри хранит начальный адрес памяти. В debug режиме хранится и длина выделенной памяти, проверяется выход за пределы.
  - Указатель можно получить, воспользовавшись экземпляром класса `Allocator`. 
  - Внутри классов можно вызывать функцию `alloc()` которая возвращает указатель. Этот метод неявно вызовется у стандартного аллокатора или у иного, если он был указан при инициализации.
  - `allocNew()` делает то же самое, что и `alloc()` только вызывает для элементов пустой конструктор
  - Метод `isNull()` - возвращает true, если указатель равен `nullptr`
  - Метод `copyData(from_ptr, len, start_index=0)`, который похож на `memcpy` в **C**, но он копирует элементы через оператор `$`.
- `ShiftedPointer` - указатель на другой указатель. Наследуется от `Pointer`
  - Имеет конструктор `ShiftedPointer<T>(Pointer<T> ptr, int shift)`
  - В классе есть поле `debug int len`, которое наследуется от `Pointer`. В конструкторе оно будет равно: `len = ptr.len - shift` и используется для проверки на выход из области.
  - Деструктор для него не вызывается, поскольку память принадлежит другому указателю.
- `Time` - класс для работы с временем
  - `millis()` - возвращает текущее время в миллисекундах
  - `nanos()` - возвращает текущее время в наносекундах
  - `measureTime(function)` или `timeIt(function)` - возвращает время выполнения function в наносекундах
- `Date` - класс для работы с датами
  - `date1.diff(date2).days()` - разница в днях между датами
- `ComplexNumber` - класс для работы с комплексными числами
- `Allocator` - стандартный аллокатор, который по умолчанию выделяет память для объектов
  - При инициализации перед любым конструктором может быть написан класс-наследник аллокатора. Экземпляр этого класса будет использоваться для выделения памяти. Пример: `list = (LinearAllocator) int<>`
  - Имеет методы `alloc()`, `realloc()`, `free(Pointer)`
  - `alloc(0)` вернёт `nullptr`
- `Database` - абстрактный класс для управления бд (как библиотека room в java)
  - Нужно переопределить методы, чтобы составлялись нужные sql запросы.
  - Подключение к БД нужно реализовывать в функции `connect()`
  - Имеет функции `select`, `insert`, `update`, которые имеют параметры `from`, `where`, `having`, `group_by`
- `Void` - специальный абстрактный класс. Обозначает, что функция ничего не возвращает. Есть `alias void = Void`
  - `type(void)` вернёт "Void"
  - `println(println())` напечатает `\n void` т.к. функция `println` возвращает `void`
  - `sizeOf(void)` будет 0. То есть может играть роль некой заглушки.
- `Pair` - класс контейнер для двух элементов
  - Стандартный синтаксис `p = Pair<int,str>()`, `p = Pair(24,"hi")`
  - Имеет поля `first`, `second`
- `Console` - класс для взаимодействия с системными командами и консолью
  - `run(command)` - принимает и возвращает строку
  - `out` - поток вывода, в который пишет `println`
- `Math` - статический класс с математическими функциями
  - `rand()` - возвращает double в пределах `[0,1)`
  - `randInt()` - возвращает число от 0 до int.MAX, `randInt(from=0, to)` - от `from` до `to`. Примеры: `randInt(5,24)`, `randInt(,15)` Есть аналогичные функции `randLong()`, `randULong()`, `randBLong()` и т.д.
- `RoRef` - класс неизменяемых ссылок. Все неизменяемые ссылки являются объектами этого класса. Применён `autocopy`.
  - Стандартный синтаксис `ref = RoRef<Animal>(a)`
  - Короткий синтаксис `ref = a`
  - Может использоваться для создания массива ссылок: `Array<RoRef<Any>> arr`. Функция println принимает именно такой параметр.
  - Применён `autocopy`, то есть при присваивании ссылка скопируется, а не создастся ссылка на ссылку.
- `Ref` - класс изменяемых ссылок. Все ссылки являются объектами этого класса. Применён `autocopy`.
  - Стандартный синтаксис `ref = Ref<Animal>(a)`
  - Короткий синтаксис `ref = &a`
  - Применён `autocopy`, то есть при присваивании ссылка скопируется, а не создастся ссылка на ссылку.
- `Hash` - класс с функциями для расчёта хэшей
  - `md5`
  - `sha1`
  - `sha256`
  - `passwordHash` - как в php
- `File` - класс для чтения и записи в файл
  - `isFile()`
  - `isDir()`
  - `mkdir()`
  - `apply()` - в отличие от `close()` не закрывает поток, а сохраняет изменения на диск.
  - В методе `_drop` вызывается функция `close()`, поэтому, при работе с файлами удобно их оборачивать в `{}`, после выхода из которых всё само закроется.
- Пакет `images` с классами разных форматов изображений: `Png`, `Jpeg`, `Bmp`
  - Все эти классы являются наследниками интерфейса `Image`, который, в свою очередь, наследник от `Collection`. То есть это трёхмерные массивы NxMx3 для RGB
  - `save(path)` - сохраняет объект в файлик
  - `load(path)` - загрузить картинку
  - `show()` - отобразить стандартной библиотекой отрисовки (если будет)
- `CodeGen` - класс для генерации строк кода
  - `fun(f_name, args)` - функция, которая генерирует строчку создания функции
  - `block(b_name, args)` - функция, которая генерирует строку с `if`, `while`, `for`, `public` или другим блоком
## ООП
- Наследование только от интерфейсов. Наследоваться от классов нельзя. При попытке наследования от другого класса компилятор выдаст: **"not in this language)"**
- Можно наследовать интерфейс от интерфейса
- Интерфейсы могут иметь в себе сигнатуру функций, реализацию некоторых функций и переменные
- Синтаксис наследования через двоеточие: `class MyArray : Array, Iterable{ ... }`
- По умолчанию все поля и методы public
- К private и protected полям можно обращаться через `_`, но для этого нужно использовать ключевое слово `unlocked`
- Модификаторы доступа можно писать как перед функцией / переменной `public main(){ ... }`, так и оборачивать всё в блок `public{ main(){ ... } }`. Можно совмещать модификаторы: `public debug static const{ int num, a, b; main(){ ... } }`
- Дженерики. Пишутся перед функцией или после имени класса. Их можно сокращать: `Array<Array<int>>` равносильно `Array<<int>>`. Можно присваивать: `foo<T>(Class cls){ T = cls }`, можно писать значение по умолчанию `foo<T=int>(){ arr = Array<T>() }`. В некоторых случаях не нужно писать `T` вообще: `fun(x) => x+5`
- При инициализации можно реализовывать интерфейс или абстрактный класс, как в java. Но таким же образом можно переопределять методы уже готового класса. Сначала переопределяется класс, потом вызывается конструктор. Пример:
```dart
arr = int[5]{
    indexOf(int i){ ... }
}
```
- Возможность создавать функции и классы внутри функций. При выходе из области видимости они бы удалялись.
- Для полей класса, у которых нет начального значения, должен быть написан тип, а инициализироваться они должны в конструкторе через `new`
- Все поля обязательно инициализируются в конструкторе, если для них не было установлено начальное значение. Для тех, которые не были инициализированы неявно вызывается конструктор по умолчанию. Для int и других численных типов задастся значение 0.
- При создании локальных переменных того-же класса можно напрямую обращаться к private полям. Снаружи так можно делать только с помощью `unlocked`
- Хоть всё является объектами, там, где возможно, компилятор будет заменять Integer на примитивный int для эффективности. Класс занимает больше места, чем просто int. Пример: `arr = int[5]` - используется примитивный тип int. `Any num = 5` - объектный тип int, поскольку ему нужно помнить, что он относится к классу int.
- В классах неявно создаётся конструктор по умолчанию без параметров. Он вызывает конструктор по умолчанию для всех полей. Можно его переопределить, но нельзя поставить private, т.к. он используется для инициализации массивов.
- `static class` означает, что класс не имеет конструктора и это просто набор полей и функций. Как namespace в C++, только обращение через `.`. Пример такого класса - `Math`
- Именованные конструкторы. Пример: `MyArray.ones(int len){ ... }`, который заполняет массив единицами. Именованные конструкторы можно использовать и с **new**: `arr = new.ones(5)`. Конструкторы `MyArray(int len)` и `MyArray.ones(int len)` не конфликтуют.
- Статичный метод может быть вызван даже у абстрактного класса.
- Во внутренней реализации у каждого объекта хранится указатель на его класс. Можно попробовать хитро хранить указатель на объект и класс в одном указателе.
- Блок `static{ ... }` в классе вызывается 1 раз перед первым обращением к классу.
- Перед вызовом деструктора вызывается метод `_drop{ ... }`, который можно переопределить. Класс `File`, например, закрывает там поток.
- В методах класса и конструкторах можно использовать сокращённый синтаксис инициализации поля класса. Вместо
```dart
setName(str name){
  this.name = name
}
```
Можно написать
```dart
setName(=name)
```
Тело функции и фигурные скобки можно не писать. Такая функция находится в классе и её не спутаешь с вызовом.
Класс с конструктором может выглядеть вот так:
```dart
class Person{
  str name
  int age
  new(=name, =age)
}
```
## Ключевые слова
- `this` - изменяемая & ссылка на текущий объект. Может использоваться для вызова конструктора this(args), как в java. При использовании в лямбда функции будет является ссылкой на объект, от которого вызвана функция. Пример: `arr.forEach(=> println(this.len+it) )`, где `this` является ссылкой на `arr`
- `parent` - ссылка на класс-родитель. Может использоваться для вызова конструктора parent(args), как `super` в java. После вызова конструктора `parent` необходимо инициализировать не все поля, а только те, которые не инициализировал класс-родитель.
- `class` - слово для создания классов. При использовании внутри класса становится ссылкой на текущий класс, равносильно `this.class``. Доступно и в static. Может использоваться для вызова конструктора class(args). При наследовании станет ссылкой на текущий класс, а не на класс родителя.
- `it` - Кортеж на аргументы функции. Т.к. это tuple, имеет конкретный тип при обращении через `[]`. Если обращаться без скобок - `it` становится ссылкой на первый аргумент функции. Равносильно `it[0]`. Чаще всего используется при передаче анонимной функции с пропущенным описанием параметров.
- `alias` - переименование функций и пакетов. Действует только в текущей области видимости. Пример: `alias новое_имя = текущее_имя`. По умолчанию неявно применён `alias int = Integer`, `alias float = Float`, `alias str = String`, `alias uint = UnsignedInt` и т.д.
- `import` - подключение пакетов. Стандартную библиотеку не нужно импортировать, достаточно написать имя класса, например: `Math.sin(.5)`. Явный импорт используется при конфликте имён для указания, берётся класс из стандартной библиотеки или из конкретной папки. `import here Math` добавляет всё в текущую область видимости. Даже класс развернёт как набор функций, где у каждой функции первым аргументом идёт объект класса. То есть можно писать просто: `sin(.5)`. Пользовательские классы так же можно не импортировать, компилятор будет искать и спускаться вниз по папкам от компилируемого файла. Если есть конфликт, будет использован класс из стандартной библиотеки, иначе нужно явно указывать путь до пакета `import lib.Math`. Можно и импортировать весь пакет: `import lib.aqua.*`. Поддерживается `as` (как в python).

- `break/continue` - выход/пропуск цикла. Можно создавать метки выхода `break start` (как в java). Также можно выйти сразу из всех вложенных циклов через `break all`
- `autocast` - пишется перед определением оператора cast `:Class`, либо перед конструктором. Означает, что при несовпадении типов, будет неявно вызван cast к этому типу, либо конструктор. `autocast` определён для всех численных типов между друг другом. Пример: `int a = Math.sqrt(7)` автоматически приведёт double к int. `int num = mystr:float` - сначала приведёт число к float, затем к int. Пример с конструктором: Допустим, у класса `MyArray` есть конструктор `autocast new(Array arr)`. Определение перед конструктором означает, что класс можно создавать таким образом: `MyArray arr = [1,2,3]`, где неявно вызовется `MyArray arr = MyArray([1,2,3])`
- `elif` - `else if`, как в python
- `new` - служит для описания конструкторов класса, вызова конструктора для переменных с уже известным типом и для описания сигнатуры класса: `Class<new(str)> cls` - означает, что класс имеет конструктор с аргументом `str`. С помощью `new` можно вызывать другой конструктор класса (В java для этого используется `this(args)`) или именованный конструктор. Примеры:
```dart
Arr<int> arr
arr = new(5)
arr = new.raw(5)
```
- `autocopy` - пишется перед определением класса. Меняет поведение `=`: данные будут копироваться, а не создаваться ссылка. Оператор `&` всё так же будет создавать ссылку. Классы `Integer`, `Long`, `Float` и т.д. помечены этим словом.
- `native` - пометка для функций, что код реализован на низком уровне (для исходников). Такие функции не могут быть переопределены.
- `debug` - этим словом помечаются переменные или блок кода `debug{ ... }`, которые должны выполняться только в режиме **debug**. Например, проверка выхода за длину массива проверяется только в debug. Обычные переменные не могут изменяться переменными `debug`. Например, есть `debug int a`. Мы не можем использовать `a` для обычных переменных: `int b = a + 5`, но можем написать `debug int c = a + b`.
- `test` - является пометкой для кода, который должен быть запущен в режиме тестов.
- `const` - ключевое слово для полей. Не может применяться при описании аргументов функции. Константы можно объявлять в конструкторе.
- `unlocked` - модификатор переменных. Разрешает обращаться к private полям объекта через `_`.
- `include` - позволяет добавлять файлы внутрь exe. `include zip "text.txt" as text` - создаст массив `Array<byte> text`, в который запишутся байты файла. `zip` - указывает, что в exe файл попадёт в сжатом виде, но в переменную `text` попадут уже разархивированные данные. Управлять параметрами сжатия можно, передав соответствующие параметры компилятору. `include "logo.png" as image:Png` - создаст объект `Png image`, где `Png` - это класс, в конструктор которого передастся массив байтов.
- `readonly` - модификатор переменных. `const` поля не могут быть переопределены через `=`, а `readonly` переменные могут, но у них можно вызывать только не изменяющие методы (за этим следит компилятор).
- `inline` - ключевое слово для функций. Оно не влияет на работу функции, а влияет на компиляцию. Вместо вызова функции код подставляется на место вызова. Если в функцию передаётся константное значение, например, `isEven(5)`, компилятор просчитывает всё, что может, убирает лишние if'ы или вообще вычислит и подставит результат функции. (В данном случае `false`). Функции, описанные с помощью `=>` по умолчанию являются `inline`. 
## Литералы
### Визуальные
- `_` - между цифрами для визуального разделения, как в java: `1_000_000`
- `e` - `million = 1e6`
- `0b` - binary
- `0o` - octal
- `0x` - hex
- `\u` - для символов: `\u00F7`
### Типовые
- Типовые литералы пишутся справа от значения `100f`
- Для явного указания типа переменной его можно указать перед переменной, либо использовать литералы: `byte b = 10`, `b = 10b`. Если переменная слишком большая для типа, она обрежется: `byte b = 1000` обрежется до 127.
- Если тип не указан, для чисел он определится автоматически исходя из значения. Сначала выбирается int, затем, если не хватает, берётся long, затем blong, затем ByteNumber.
- `b/ub` - byte/ubite
- `s/us` - short/ushort
- `u` - uint
- `l/ul` - long/ulong
- `bl/ubl` - blong/ublong
- `bn` - ByteNumber
- `ln` - LongNumber
- `f` - float
- `sf` - short float
- `js` - Json
- `dt` - Date
- `/regex/` - Regex
- `"string"` - String
- `'c'` - char. Если в одинарных кавычках `'` будет больше 1 символа, они будут считаться строкой `str`.
## Примеры кода
### Hello world
```dart
println("Hello, world!")
```
### Вывести таблицу умножения NxM
```dart
n = input("Введите N"):int
m = input("Введите M"):int
arr = int[n][m]
for (i : arr.len) {
	for (j : arr[0].len) {
		arr[i][j] = (i+1)*(j+1)
	}
}

println("Таблица $n x $m")
for (line : arr)
	println(#line, split = "\t")
```
### Вывести сумму и произведение введённых чисел
```dart
arr = inputLine("Введите ряд чисел").split().map(double)

s = arr.sum()
p = arr.prod() //product
println("Sum: $s")
println("Product: $p")
```
### Числа Фибоначчи
```dart
n = inputLine("Введите N"):int
fib(int n) => if (n < 2) 1 else fib(n-1)+fib(n-2)
for (i : 9)
    print(fib(i)," ")
//1 1 2 3 5 8 13 21 34
```
### Найти самый часто повторяющийся элемент массива. Если их несколько, вывести все.
```dart
import Counter
arr = inputLine("Введите ряд чисел").split().map(int)
c = Counter(arr)
max_value = c.values.max()
println( #c.filter(=>this[it]==max_value) )
```
### Найти факториал
```dart
import Math
println(factorial(1000))
```
### Переписанный пример использования классов с сайта языка Dart (dart.dev)
```dart
interface Item {
  void use()
}

class Chest<T> : Item {
  List<T> contents

  Chest(List<T> list) => contents = $list

  use() => println('${this.class.name} has ${contents.len} items.')
}

class Sword : Item {
  const damage = 5

  use() => println('${this.class.name} dealt $damage damage.')
}

class DiamondSword : Sword {
  const damage = 50
}

main() {
  chest = Chest<Item>([
    DiamondSword(),
    Sword(),
  ])

  chest.use()

  for (item : chest.contents) {
    item.use()
  }
}
```
## Компилятор
- Если в папке присутствует файл `aquaconfig`, компилятор применит настройки, указанные там. Аналог `makefile`.
- Отслеживание, является ли функция изменяющей и изменяется ли каждая из переменных. В следствии, такие переменные можно сделать константными. Так же это отслеживание пригодится для взаимодействия с debug переменными.
- Для объектов, возвращаемых из функций не вызывается деструктор.
- Запуск программы. Если в файле есть функция main, запустится функция main (может быть с параметрами `main(str[] args)`). Если в компилируемом файле нет функции main, код запустится, как если бы весь этот код был обёрнут в main.
- Стандартное расширение - **`main.aq`** или **`main.aqua`**. Скомпилированный файл будет называться **`main.water`**. Он содержит в себе синтаксическое дерево в сжатом виде. Такой файл можно открыть с помощью программы, поставляемой в пакете **aqua**. Такие файлы может отобразиться в двух представлениях: стандартный валидный aqua код или aqua код с дополнительной информацией, такой как рассчитанные типы переменных, количество вызовов функций, является ли функция изменяющей для объектов. Скомпилированная статическая библиотека - **`library.snow`**, динамическая библиотека - **`library.ice`**
- Компилятору на вход можно передать корневую директорию проекта, чтобы создать исполняемый файл, либо конкретный путь до файла, чтобы он скомпилировал из него object-файл
- В исключениях пишется строка ошибки. Как минимум, в debug режиме
- Скомпилированные файлы и библиотеки можно было бы запустить, открывалось бы красивое окно с перечнем классов и функций с их сигнатурами, которые в этом файле скомпилированы.
- Компилятор мог бы не только собирать исполняемый файл, но и выдавать промежуточный код, в котором можно просмотреть, какие инструкции вызываются. Такие файлы имели бы расширение **.H2O** - аналогия с мельчайшей частичкой воды.
- Компилятор может выдавать тот же файл `.aqua` с небольшими оптимизациями, по типу удаления неиспользуемых переменных.
- Компилятор запущенный с параметром `expand` вернёт файл, в котором добавлена дополнительная информация: подписанны все типы и места вызовов деструкторов
- Компилятор можно запустить в режиме profiler, в котором он фиксирует и отображает всю статистику полученной программы: количество вызовов функций, время вызова, время работы функций, затраченную память.
- Компилятор можно запустить со специальным параметром, который отформатирует код по стандарту.
- Компилятор может сжать файлы и помещать внутрь exe (как в apk на android) с помощью ключевого слова `include`. По сути, в exe поместится байтовый массив. Его изменения не сохранятся, т.к. массив зашит в exe.
- У компилятора есть профили запуска. Основные из них - `debug` и `release`. Например, команда `aqua debug main.aq` соберёт main.exe файл без оптимизаций с debug-блоками кода. Данная команда равносильна `aqua --debug-blocks --debug-mode -o0 --out main.exe main.aq`. То есть вместо всех этих параметров мы можно написать `debug`. Таким образом, у программиста есть возможность скомпилировать код с оптимизациями и при этом не убирая debug-блоки: `aqua --debug-blocks -o5 --out main.exe main.aq`. К имеющемуся профилю можно добавлять параметры. Пример: `aqua release -o3 --out test.exe`.
- Пользовательские библиотеки устанавливаются глобально. Но чтобы использовать их в проекте, нужно, в файл `requirements.aqr` написать названия импортов и версий библиотек, которые должны подключиться в этот проект.
- Простые функции по типу `fun(int x) => x*x+4` компилятор будет разворачивать и подставлять значение, а не вызывать функцию. (Делать её `inline`)
- Режим компиляции, при котором там, где возможно, функции разворачиваются и подставляются как inline для эффективности.
- Затратный режим компиляции, для эффективного исполнения программ. Сначала компилируется обычная программа, которая запускается и все объекты которые она создаёт в оперативке сохраняются. Затем компилируется вторая итоговая программа, где вместо создания объектов и вызовов конструкторов в оперативку из exe записываются байты объекта, которые были сохранены на предыдущем этапе.
- Компилятор анализирует циклы for и, если обнаруживает операцию копирования массива из одной его части в другую, заменяет такой цикл функцией `memcpy`.
- Параметр `--nostd` для сборки без стандартной библиотеки (например, без ввода-вывода). Также уменьшает размер кода и делает некоторые оптимизации для запуска на микроконтроллерах.
- Идея зависимости объекта от родительского (object dependency). Если выходит из области видимости родительский объект, то и вызывается деструктор для всех дочерних. Это контролирует компилятор.
- Режим компиляции, который по максимому делает функции inline и возрастает размер приложения, и режим компиляции, в котором повторяющийся код автоматически выносится в функции, то есть уменьшается размер, но увеличивается время выполнения.
# Не забыть
in, is как в python
Нужны ли скобки в if?
Вместо `namespace` использовать `static class`?
`extends`, `implements` - наследование как в java или через : ?
Для всех объектов сделать class - полем или функцией?
срезы массива? вертикальные стоил ли?
какие примеры кода ещё написать?

std::move
switch case как в kotlin
GraalVM, Truffle, LLVM, JIT компиляция
`args` - ссылка на текущие аргументы функции. Если в функцию передан аргумент `value`, можно обратиться к нему через `args.value`. Является словарём типа Any
`->` - проверяет, содержится ли элемент в контейнере (как в python). Пример: `if (x -> arr)`
ключевое слово required, compile, stackalloc, heapalloc
array zeros, ones, fill(index), raw, range
Ссылки в объектах и массивах
Макросы
[...]
for работает и для unsigned и в обратном порядке
System console
slice(int start = 0, int end)
list = List(Array<int>(5));
Math.randInt
12:long
main

LinkedList - head, body, tail
with
yield
Как сделать итератор?

Tuple<Any,int> iterator()

Оператор /. для деления с точкой

T& iter(int index)

<only T>
<child T>
<parent T>

temporary object

Sequence

Collection< data = Iterable<int> >

read или input?
readln

Конструктор как new, а не название класса

compile { ... } для проверок компилятору ByteNumber(size) -> size>16
compileAssert()

анонимная функция как { println("hi") }

конструкция with{ } внутри которой мы можем вызывать фукции объекта без this

база данных, обращение к которой происходит не через sql запросы, а через функции, которые напрямую обращаются к бд. (не нужно парсить sql)

Оставить только mut ссылки?

Специальные объекты-блоки. Синтаксис: слово{ ... }

Scope functions чтобы не писать много раз вызов функций одного и того же объекта
animal{
  feed()
  wash()
  mood++
  go_walk(this)
}
То же самое что
animal.feed()
animal.wash()
animal.mood++
go_walk(animal)

Концепция зависимости объектов друг от друга (удаляются вместе), за которой следит компилятор

Всё является ссылками, как в java? I like it
a = Animal()
Animal ref
Animal copy
ref = a
copy = $a

arr1 = Animal[5] //массив из ссылок (будет занимать в памяти 5 * sizeOf(Ptr) )
arr2 = Animal$[5] //массив из значений (будет занимать в памяти 5 * sizeOf(Animal) )

Стоит ли массивы делать через вызов конструктора? Привязка к стандартной библиотеке

На сайте сделать дерево всех наследований классов стандартной библиотеки.

has вместо contains?

class A{
  B b
  setB(B new_b)=>b = $new_b
}
В переменную b не может быть записана ссылка на new_b, только копия, поскольку new_b из другой области видимости. Лучше переписать функцию как setB(B$ new_b)=>b = new_b

оператор & для получения ссылки даже на переменную autocopy
$ - copied object
& - free object

Подумать о ситуации:
o = Obj()
o2 = Obj()
Как лучше?
o2 = o
или
o2 = &o

применение к столбцу или строке в матрице функции, как в excel для расчётов. То есть каждая ячейка хранит в себе значение и функцию. При обращении к какой-то ячейке, если она зависит от другой, она вызвает рекурсивно другие ячейки (как в excel)

None и null - это специальные значения. Для своего класса можно определить своё специальное значение (можно его назвать special) и потом сравнивать: if (my_obj == special)

inline, cross inline функции в kotlin

singletone или single (как ключ. слово object в kotlin)

Кастомные аннотации @. Пишется annotation{ логика аннотации }. В ней можно взаимодействовать с рефлексией: получать типы и ссылки на аргументы функции, помеченные этой аннотацией

Если функция не имеет аргументов, она может быть записана как
foo{
  ...
}

вместо указателей memory object

именовать debug блоки, чтобы потом выбирать, какие скомпилировать?

функция в функции:
foo(){
  bar(){

  }
}
и вызов её как foo.bar()

функции, которые могут возвращать значения разных типов в зависимости от их аргументов

streams: arr..map() оператор .. на вызове iterator прерывает выполнение цикла

data class'ы, которые можно наследовать друг от друга

после слова class не указывать название `class{ ... }`, потому что название класса будет такое же, что и название файла

promise о том, что ты заполнишь ссылку позже

лого A(,)ua

подобие yield в python, но отличие в том, что она будет возвращать не генератор, а конкретное значение. Экземпляр состояния функции хранится в памяти и выполнение продолжается с того места, с которого вышло через yield

julia> f = +;
julia> f(1,2,3)
>>>6 

Взаимодействие с функцией, как с объектом
inst = function.instance()
inst.age = 20
inst.name = "Vova"
inst.call()

Сдвинутые числа:
Например, число int, которое сдвинуто на 10 цифр в отрицательную часть. То есть его значение может быть -10, но не может быть -11. И занимает оно 4 байта, как и int.

Сделать итерацию по массиву упрощённым синтаксисом.

Как часто используются те или иные конструкции. Например, какие циклы чаще всего используются: перебор, вычисления, вывод?


Match может обращаться к it и возвращать значение:
```
result = match(string){
    "+" => "сложение",
    "x" || "*" => "умножение",
    it.startsWith(".") => "метод",
    string2 {
        while (something){
          string2 =[:2]
          if something
            return something
        }
      },
    default => "действие по умолчанию"
}
```

Null может быть только в объекте Memory (нулевой указатель) и при обращении к объекту memory[index] внутри вызовется проверка и если указатель внутри null, вызовется Exception

Aqua Query Language - AQL для запросов к бд.

Оператор ... для распаковки вместо #

Оператор ?

Класс по измерению времени выполнения. Вызываешь после выполнения какого-то фрагмента кода `timePoint("First point")`, потом другой фрагменты и `timePoint("Second point")` а затем в самом конце вызываешь `finalPoint()`, которая выводит что-то подобное:
```
First point: 200ms 20%
Second point: 500ms 50%
End point: 300ms 30%

Total: 1000ms
```

Указывать контекст, чтобы при вызове функции она неявно вызывалась у определённого объекта. Пример:
```
arr = [1,2,3]
cat = Animal()
arr:map, cat:run{
  map(=>do_smth) //arr.map()
  cat.name = "Tom"
  run() //cat.run()
}
```
